\section{Programming WSNs with TinyOS}\label{capitolo8}
\subsection{Wireless Sensor Networks}
Le WSN sono reti di sensori che si contraddistinguono dalle normali reti per il gran numero di nodi presenti ma molto densi, questi nodi solitamente non hanno un ID globale come un IP. Le WSN non sono interattiva ma si basano su applicazioni data-centriche e evento-centriche. La comunicazione è di tipo asimmetrica dai nodi verso un datacenter centrale, molto spesso la comunicazione è \emph{content-based} rispetto a una comunicazione \emph{identity-based}. Il tipo di rete utilizzata dipende molto dall'applicazione. Solitamente questo tipo di reti sono sviluppate e installate in ambienti ostili e inaccessibili, per questo i sensori devono auto-organizzarsi, essere \emph{exception-free} ovvero non presentare comportamenti indesiderati e soprattutto è impossibile sostituire la fonte di energia perciò è necessario che l'utilizzo di tale risorsa sia gestito accuratamente.\\
Nella maggior parte dei casi i sensori sono fissi e molto ravvicinati, tuttavia esistono casi in cui questo non è vero come nel caso di applicazioni mobile come nei body sensor network; in ogni caso abbiamo che i sensori sono fissi è solo l'ambiente in cui sono posizionati che si muove.\\
Come nelle comunicazioni mobili standard anche in questo caso che la comunicazione è il punto centrale del sistema ed è necessario sfruttare al massimo la comunicazione wireless tenendo conto di tutti i problemi derivanti come collisioni, effetti mulitpath ecc.; inoltre la comunicazione è l'attività che consuma più energia, la banda è scarsa e deve essere condivisa, infine, la topologia è dinamica. Tuttavia esistono diverse differenze rispetto ad una rete wireless tradizionale, innanzi tutto il numero dei nodi è molto maggiore è quindi impossibile identificarli tramite un ID globale, il fattore energetico è molto più restrittivo, la natura della comunicazione è diversa ma soprattutto i nodi di una rete tradizionali sono indipendenti gli uni dagli altri nelle WSN questo non è possibile.\\
Un altro dispositivo simile ad un sensore di una WSN è RFID (\emph{Radio Frequency Identification}) il quale viene utilizzato in moltissime applicazioni come ad esempio al posto delle chiavi o dei codici a barre. Un sensore RFID è simile ad un sensore di una WSN in quanto entrambi interagiscono con l'ambiente, ed entrambi utilizzano il wireless per la comunicazione. Tuttavia RFID è un dispositivo passivo ovvero non ha bisogno di energia per funzionare, ed inoltre sono dispositivi stupidi non in grado di effettuare alcuna computazione.\\
Le applicazioni nelle quali si utilizzano WSN sono i più vari, partiamo da ambiti militari dove si utilizzano per monitorare gli equipaggiamenti, le munizioni, le forze alleate ma anche come identificazione di attacchi nucleari biologici o chimici. Si utilizzano inoltre come applicazioni per monitorare l'ambiente sia come semplici sensori per le condizioni ambientali a monitoraggi più complessi come monitoraggi di terreno e piante o anche monitoraggi di frane ed incendi forestali. In ambito medicale si possono monitorare la posizione di dottori e pazienti all'interno di un ospedale, la somministrazione dei medicinali, telemonitoring di dati fisiologici nei pazienti.
\subsection{Architettura della comunicazione}
La comunicazione è alla base di una WSN, esiste una grande varietà di combinazioni tra i diversi livelli di comunicazione per combinare ad esempio un efficente consumo di energia per la comunicazione tramite il mezzo wireless. Si cerca perciò di favorire l'interoperabilità.\\
Ma perchè non utilizzare i normali protocolli di routing? I motivi sono molti ad esempio l'impossibilità di utilizzare un identificativo per i nodi univoco a causa dell'alto numero di nodi, inoltre i sensori sono molto limitati in consumi, potenza di calcolo e memoria; sono sottoposti ad un alta probabilità di fallimento ed infine la topologia cambia frequentemente.\\
Esistono diversi protocolli di routing che si possono suddividere in diverse categorie:
\begin{itemize}
	\item Protocolli data-centrici: flooding, gossiping, SPIN, SAR, ecc.
	\item Protocolli gerarchici: LEACH , TEEN, APTEEN, PEGASIS
	\item Protocolli basati sulla posizione: MECN, SMECN, GEAR
\end{itemize}
\subsubsection{Routing data centrico}
Da quando i sensori vengono posizionati in gran numero ed in modo casuale è difficile assegnargli degli §§ID specifici e senza un identificativo univoco è quasi impossibile prelevare i dati; tuttavia esiste una soluzione per prelevare e dirigere i dati verso il centro di raccolta, questo tipo di protocolli si basano sulla descrizione dei dati. Tuttavia questo richiede che i dati siano corredati da attributi nominati in modo che essi possano essere interrogati facilmente.\\
Alcuni algoritmi si basano sulla disseminazione dei dati come il \emph{Flooding} che invia i dati a tutti i vicini e il \emph{Gossiping} che invia i dati ad un vicino selezionato casualmente, entrambi questi algoritmi sono semplici ma portano ad un implosione in quanto molti dati raggiungono uno stesso nodo ed inoltre vi è una sovrapposizione in quanto più nodi possono leggere gli stessi valori ma soprattutto questi due protocolli sono inefficienti a livello di consumo di energia.\\
Esistono poi degli algoritmi di \emph{diffusione diretta} in questo caso ogni sensore assegna degli attributi ad ogni dato generato, gli altri nodi esprimono il loro \emph{interesse} verso alcuni di questi attributi, questo interesse può essere quantificato da un \emph{gradiente} che indirizza la diffusione dei dati. La consegna dei dati segue la strada imposta dal gradiente, tale meccanismo è simile al content-based nel contesto del publish-subscribe. Uno dei protocolli che sfrutta questo fattore è il \emph{CCBR (Context and Context Based Routing)} in questo caso l'interazione tra i nodi è di tipo datacentrica ma anche di tipo \emph{context aware}. In questo protocollo ogni nodo mantiene traccia dalla distanza che lo separa dal collettore dei dati, le proprietà dei nodi sono mantenute dai nodi stessi e il content based è effettuato solo dai nodi che inviano i dati. Il CCBR sfrutta alcune caratteristiche:
\begin{itemize}
	\item utilizza \emph{link-layer brodcast} quando è possibile per essere robusto contro il cambio di topologia e minimizzare il traffico
	\item usa un approccio \emph{receiver-based} ovvero è il nodo ricevente che decide se accettare il pacchetto in ingresso e reinviarlo.
	\item si utilizza un approccio \emph{opportunistico} ogni nodo decide se inoltrare il pacchetto in base ad una decisione locale la quale dipende dalla sua distanza dal centro di raccolta.
	\item infine si utilizza un meccanismo di \emph{ack implicito}
\end{itemize}
\subsubsection{Protocollo gerarchico}
I protocolli di tipo gerarchico sono stati introdotti perché sono più efficienti sia in termini di overhead di traffico sia in termini di consumo di energia, i diversi sensori formano un cluster che viene controllato da una \emph{cluster-head} la quale aggrega e fonde i dati per risparmiare energia.\\
Uno dei più diffusi protocolli gerarchici è il \emph{LEACH (Low Energy Adaptative Clustering Hierarchy)} il quale sfrutta l'idea di selezionare in modo casuale la testa del cluster e questa può utilizzare uno qualsiasi dei protocolli di route affidabili per inviare dati al sink. L'algoritmo si suddivide in due fasi che vengono ripetute periodicamente la prima fase detta di \emph{setup} comporta che un insieme di nodi a caso elegga se stesso come testa del cluster, questi nodi avvisano tutti gli altri di essere la testa, gli altri nodi selezionano la testa in base al valore RSSI (risparmio di energia). La seconda fase è chiamata di \emph{steady state} durante questa fase i sensori raccolgono i dati e le inviano all'head la quale li raccoglie e li aggrega.